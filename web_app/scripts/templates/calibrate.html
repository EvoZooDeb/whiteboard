<!doctype html>
<html style="height:100%;">
<head>
    <title>Annotate Your Images</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://maxcdn.bootstrapcdn.com/bootswatch/3.3.7/cerulean/bootstrap.min.css" rel="stylesheet">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.0/jquery.min.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/jqueryui/1.13.2/jquery-ui.min.js"></script>
    <link rel="stylesheet" src="https://cdn.jsdelivr.net/gh/cotton123236/zoomist@latest/dist/zoomist.min.css"/>
    <script src="https://cdn.jsdelivr.net/gh/cotton123236/zoomist@latest/dist/zoomist.min.js"></script>
</head>

<style>
  .sidebar{
    width: 25%;
    height: 100%;
    float: left;
    z-index: 10;
    margin-bottom: 0px;
  }
  .content{
    width: 75%;
    height: 100%;
    float: right;
    z-index: 10;
    margin-bottom:0px;
  }
  .row{
    padding: 10px 5px;
    border-bottom: 3px solid black;
  }
  .image-name{
    font-size: 16px;
  }
  .counter{
    font-size: 18px;
  }
  .content-image{
    margin-top:10px;
  }

/*  .stone {
  position: absolute;
  background: #000;
  width: 10px;
  height: 10px;
  border-radius: 50%;
} */
/*  .stone{
     position: absolute;
     width:50px;
     height:50px;
     background:
     linear-gradient(#FFA405 0 0),
     linear-gradient(#FFA405 0 0);
     background-position:center;
     background-size: 50% 2px,2px 50%; /*thickness = 2px, length = 50% (25px)*/
     background-repeat:no-repeat;
  } */
  .bowl {
  width: 100%;
  height: 100%;
  transition: transform .0s;
  transform-origin: 0 0;
  }

 /* img {
  width: auto;
  height: auto;
  max-width: 100%;
  } */
</style>
<script>
	function showDiv() {
	      console.log("ASD");
	      document.getElementById('Submit').style.display = "none";
	      document.getElementById("page").style.display = "none";
	      document.getElementById('loadingGif').style.display = "block";
	      document.getElementById('loadingMessage').style.display = "block";
	}
</script>
<div id="loadingGif" style="display:none"><img src="https://media.giphy.com/media/3oEjI6SIIHBdRxXI40/giphy.gif"></div>
<div id="loadingMessage" style="display:none"<label> Object detection, transformation and pixel analysis in progress. This could take 10-12 second per image.</label></div>

<body>
<div class="wrapper" id = "page"> 
<nav id="sidebar" class="sidebar">
  <div class="panel panel-default" style="height:100%;">
      <div class="panel-heading">
        <h3 class="panel-title"><b><center>Coordinates</center></b></h3>
      </div>
        <div class="panel-body">
            <div class="list-group">
              {% for label in labels %}
                <div class="list-group-item">
                    <div class="input-group">
                        <span class="input-group-addon" id="id">{{ label.id }}</span>
			<!-- {% if label.name %} -->
			<text style="background-color:#E5E7E9;" class="form-control custom-control" style="resize:none">{{ label.x_coord }}, {{label.y_coord}}</text>
                       <!-- {% else %}
                            <input id= "{{ label.id }}" onkeydown="if (event.keyCode == 13) { label(this.id, this.value); }" type="text" class="form-control" placeholder="Label Name" autofocus></input>
			    {% endif %} -->
                        <span class="input-group-btn">
                            <button id= "{{ label.id }}" class="btn btn-danger" onclick="window.location.replace('/remove_calibrate/' + this.id)" type="button"><b>-<b></button>
                        </span>
                    </div>
                </div>
                {% endfor %}
            </div>
        </div>
    </div>
</nav>
<div id="content" class="container content">
    <div class="row">
    <!--  <a href="/final" class="btn btn-primary" style="float:right; font-size:18px;" type="submit"> -->
    <form action="{{ url_for("submit_calibrate")}}" method="post" onsubmit= "showDiv()" >
      <input class="btn btn-primary" style="float:right; font-size:18px;" type="submit" id = "Submit">
    </form>
	<!-- </a> -->
    </div>
    <div id = "content-image" class = "content-image">
	<canvas id="canvas" class = "bowl" style="width:100%; height:100% margin: 0; padding: 0;">
    	</canvas> 
    </div>
</div>
</div>
<script type="text/javascript">
    var labels = {{ labels|tojson|safe }};
    var canvas = document.getElementById("canvas");
    var ctx = canvas.getContext("2d");
    // variables relating to existing circles
    var circles = [];
    var stdRadius = 25;
    var draggingCircle = -1;
//load and display image
    var image = new Image();
    image.onload = function(e) {
      ctx.canvas.width = image.width;
      ctx.canvas.height = image.height;
      canvas.width = image.width;
      canvas.height = image.height;
      ctx.drawImage(image, 0, 0);
      for (i = 0; i < labels.length; i++){
            drawLabels(Math.round(labels[i].x_coord), Math.round(labels[i].y_coord));
            //drawLabels(labels[i].x_coord, labels[i].y_coord);
            circles.push({
		id: labels[i].id,    
                x: labels[i].x_coord,
                y: labels[i].y_coord,
        	radius: stdRadius
            });
        }
      console.log("LABELS");
      console.log(labels);
      console.log(circles);
//      drawAll();
    };
    image.style.display="block";
    image.src = "image/{{ image }}";
	
    // canvas related variables
    // references to canvas and its context and its position on the page
   // var $canvas = $("#canvas");
   // var canvasOffset = $canvas.offset();
   // var offsetX = canvasOffset.left;
   // var offsetY = canvasOffset.top;
   // var scrollX = $canvas.scrollLeft();
   // var scrollY = $canvas.scrollTop();
   // var cw = canvas.width;
   // var ch = canvas.height;
    
    // flag to indicate a drag is in process
    // and the last XY position that has already been processed
    var isDown = false;
    var lastX;
    var lastY;
    

    var drawLabels = function(x_coord, y_coord){
  	    ctx.strokeStyle = "orange";
            ctx.lineWidth="6";
            ctx.beginPath();
	    ctx.moveTo(x_coord, y_coord);
	    ctx.lineTo(x_coord, y_coord + 25);
	    ctx.moveTo(x_coord, y_coord);
	    ctx.lineTo(x_coord, y_coord - 25);
	    ctx.moveTo(x_coord, y_coord);
	    ctx.lineTo(x_coord + 25, y_coord);
	    ctx.moveTo(x_coord, y_coord);
	    ctx.lineTo(x_coord - 25, y_coord);
            ctx.closePath();
            ctx.stroke();
    }
    // clear the canvas and redraw all existing circles
    function drawAll() {
        console.log(circles);
        ctx.clearRect(0, 0, canvas.width, canvas.height);
      	ctx.drawImage(image, 0, 0);
        for (var i = 0; i < circles.length; i++) {
            var circle = circles[i];
            console.log(circles[i]);
  	    ctx.strokeStyle = "orange";
            ctx.lineWidth="6";
            ctx.beginPath();
	    ctx.moveTo(circle.x, circle.y);
	    ctx.lineTo(circle.x, circle.y + 25);
	    ctx.moveTo(circle.x, circle.y);
	    ctx.lineTo(circle.x, circle.y - 25);
	    ctx.moveTo(circle.x, circle.y);
	    ctx.lineTo(circle.x + 25, circle.y);
	    ctx.moveTo(circle.x, circle.y);
	    ctx.lineTo(circle.x - 25, circle.y);
            ctx.closePath();
            ctx.stroke();
           // ctx.beginPath();
           // ctx.arc(circle.x, circle.y, circle.radius, 0, PI2);
           // ctx.closePath();
           // ctx.fillStyle = circle.color;
           // ctx.fill();
        }
    }
    
    function handleMouseDown(e) {
        // tell the browser we'll handle this event
        e.preventDefault();
        e.stopPropagation();
        console.log("CLICK");
        // save the mouse position
        // in case this becomes a drag operation
        var imageElement = document.getElementById('canvas');
    	elementBox = imageElement.getBoundingClientRect()
    	coordX = event.clientX - Math.round(elementBox.x);
    	coordY = event.clientY - Math.round(elementBox.y);
    	complexX = complexCoord(coordX, elementBox.width);
    	complexY = complexCoord(coordY, elementBox.height);
    	let width = image.width;
    	let height = image.height;
    	complexX_scaled = Math.round(complexX * width)
    	complexY_scaled = Math.round(complexY * height)
    //	complexX_scaled = complexX * width
    //	complexY_scaled = complexY * height
    	lastX = complexX_scaled
    	lastY = complexY_scaled
	console.log(lastX);
	console.log(lastY);
    
        // hit test all existing circles
        var hit = -1;
        for (var i = 0; i < circles.length; i++) {
            var circle = circles[i];
            var dx = lastX - circle.x;
            var dy = lastY - circle.y;
            if (dx * dx + dy * dy < circle.radius * circle.radius) {
                hit = i;
            }
        }
    	// if control key is down
        if (event.ctrlKey) {
           // if no hits then pass
           // if hit then remove circle
           if (hit < 0) {
	   	//pass	
           } else {
	       c_id = circles[hit].id;
               window.location.replace("/remove_calibrate/" + c_id);
           }
	// if control key is up
	} else {
           // if no hits then add a circle
           // if hit then set the isDown flag to start a drag
           if (hit < 0) {
               circles.push({
                   x: lastX,
                   y: lastY,
	   	radius: stdRadius
               });
	     console.log("POSSCALE");  
	     console.log(pos, scale);  
             window.location.replace("/add_calibrate/" + (labels.length + 1) +
                    "?x_coord=" + lastX +
                    "&y_coord=" + lastY +
	       	    "&zoom_pos_x=" + pos.x +
	            "&zoom_pos_y=" + pos.y +
		    "&zoom_scale=" + scale);
           } else {
               draggingCircle = circles[hit];
	       c_id = circles[hit].id;
	       console.log("ID");
	       console.log(c_id);
               isDown = true;
           }
	}
    }
 
 // Ctrl + click works smoother
 //   function handleDoubleClick(e) {
 //       // tell the browser we'll handle this event
 //       e.preventDefault();
 //       e.stopPropagation();
 //       console.log("DBCLICK");
 //       // save the mouse position
 //       var imageElement = document.getElementById('canvas');
 //   	elementBox = imageElement.getBoundingClientRect()
 //   	coordX = event.clientX - Math.round(elementBox.x);
 //   	coordY = event.clientY - Math.round(elementBox.y);
 //   	complexX = complexCoord(coordX, elementBox.width);
 //   	complexY = complexCoord(coordY, elementBox.height);
 //   	let width = image.width;
 //   	let height = image.height;
 //   	complexX_scaled = Math.round(complexX * width)
 //   	complexY_scaled = Math.round(complexY * height)
 //   	lastX = complexX_scaled
 //   	lastY = complexY_scaled
 //       console.log(lastX);
 //       console.log(lastY);
 //   
 //       // hit test all existing circles
 //       var hit = -1;
 //       for (var i = 0; i < circles.length; i++) {
 //           var circle = circles[i];
 //           var dx = lastX - circle.x;
 //           var dy = lastY - circle.y;
 //           if (dx * dx + dy * dy < circle.radius * circle.radius) {
 //               hit = i;
 //           }
 //       }
 //   
 //       // if no hits then pass
 //       // if hit then remove circle
 //       if (hit < 0) {
 //       	//pass	
 //       } else {
 //           c_id = circles[hit].id;
 //           window.location.replace("/remove_calibrate/" + c_id);
 //       }
 //   }
    
    function handleMouseUp(e) {
        // tell the browser we'll handle this event
        e.preventDefault();
        e.stopPropagation();
    
        // stop the drag
        isDown = false;
	if (draggingCircle != -1){
	console.log("ID");
	console.log(c_id);
        window.location.replace("/add_calibrate/" + c_id +
               "?x_coord=" + draggingCircle.x +
               "&y_coord=" + draggingCircle.y+
	       "&zoom_pos_x=" + pos.x +
	       "&zoom_pos_y=" + pos.y +
	       "&zoom_scale=" + scale);
	}
    }
    
    function handleMouseMove(e) {
    
        // if we're not dragging, just exit
        if (!isDown) {
            return;
        }
    
        // tell the browser we'll handle this event
        e.preventDefault();
        e.stopPropagation();
    
        // get the current mouse position
        var imageElement = document.getElementById('canvas');
    	elementBox = imageElement.getBoundingClientRect()
    	coordX = event.clientX - Math.round(elementBox.x);
    	coordY = event.clientY - Math.round(elementBox.y);
    	complexX = complexCoord(coordX, elementBox.width);
    	complexY = complexCoord(coordY, elementBox.height);
    	let width = image.width;
    	let height = image.height;
    	complexX_scaled = Math.round(complexX * width)
    	complexY_scaled = Math.round(complexY * height)
    	//complexX_scaled = complexX * width
    	//complexY_scaled = complexY * heigt
    	mouseX = complexX_scaled
    	mouseY = complexY_scaled
    
        // calculate how far the mouse has moved
        // since the last mousemove event was processed
        var dx = mouseX - lastX;
        var dy = mouseY - lastY;
	console.log("DRAG PARAMS");
	console.log(mouseX);
	console.log(mouseY);
	console.log(lastX);
	console.log(lastY);
	console.log(dx);
	console.log(dy);
    
        // reset the lastX/Y to the current mouse position
        lastX = mouseX;
        lastY = mouseY;
    
        // change the target circles position by the 
        // distance the mouse has moved since the last
        // mousemove event
        draggingCircle.x =  lastX + dx;
        draggingCircle.y =  lastY + dy;
	console.log("ASD")
	console.log(draggingCircle.x);
	console.log(draggingCircle.y);
    
        // redraw all the circles
	console.log("REDRAW")
        drawAll();
    }
    
    // listen for mouse events
    $("#canvas").mousedown(function (e) {
        handleMouseDown(e);
    });
    $("#canvas").mousemove(function (e) {
        handleMouseMove(e);
    });
    $("#canvas").mouseup(function (e) {
        handleMouseUp(e);
    });
    $("#canvas").mouseout(function (e) {
        handleMouseUp(e);
    });

// Implemented Ctrl+click = remove id instead
//    $("#canvas").dblclick(function (e){
//	handleDoubleClick(e);
//	});

// Zoom manual
   const container = document.querySelector('.content-image');
   const image_z = document.querySelector('.bowl');
   const speed = 0.5;
   console.log("ZOOM");
   console.log(image_z.offsetWidth);
   console.log(image_z.offsetHeight);
   let size = { 
     w: image_z.offsetWidth, 
     h: image_z.offsetHeight 
   };
   if (labels.length > 0){
   	pos = { x: 0, y: 0 };
	pos.x = Number(labels[labels.length-1].zoom_pos_x);
	pos.y = Number(labels[labels.length-1].zoom_pos_y);
   	target = { x: 0, y: 0 };
   	pointer = { x: 0, y: 0 };
	scale = Number(labels[labels.length-1].zoom_scale);
	console.log("POSSCALE_SEC");
	console.log(pos);
	console.log(scale);
   	image_z.style.transform = `translate(${pos.x}px,${pos.y}px) scale(${scale},${scale})`;
   } else{
 	console.log("ZEROLABEL");
 	pos = { x: 0, y: 0 };
 	console.log("POSSCALE_ZERO");
 	console.log(pos);
 	target = { x: 0, y: 0 };
 	pointer = { x: 0, y: 0 };
 	scale = 1;
   };
   window.addEventListener('wheel', event => {
     event.preventDefault();
     if (event.ctrlKey) {
	console.log("POSSCALE_BEG");
	console.log(pos);
	console.log(scale);
        pointer.x = event.pageX - container.offsetLeft;
        pointer.y = event.pageY - container.offsetTop;
        target.x = (pointer.x - pos.x) / scale;
        target.y = (pointer.y - pos.y) / scale;
       
        scale += -1 * Math.max(-1, Math.min(1, event.deltaY)) * speed * scale;
	console.log("POSSCALE_TEST");
	console.log(pos);
	console.log(scale);
        
        const max_scale = 4;
        const min_scale = 1;
        scale = Math.max(min_scale, Math.min(max_scale, scale));
   
	console.log("TARGET_TEST");
	console.log(target.x);
	console.log(target.y);

        pos.x = -target.x * scale + pointer.x;
        pos.y = -target.y * scale + pointer.y;
   
        if (pos.x > 0) pos.x = 0;
        if (pos.x + size.w * scale < size.w) pos.x = -size.w * (scale - 1);
        if (pos.y > 0) pos.y = 0;
        if (pos.y + size.h * scale < size.h) pos.y = -size.h * (scale - 1);
	console.log("POSSCALE_FIRST");
	console.log(pos);
	console.log(scale);
        image_z.style.transform = `translate(${pos.x}px,${pos.y}px) scale(${scale},${scale})`;
     } else {
        pos.x  -= event.deltaX * 2;
        pos.y -= event.deltaY * 2;
     }
   }, { passive: false });


   function complexCoord(coord, coordMax) {
   	let complexCoord = coord / coordMax;
    	return complexCoord
    	    }

</script>
</body>
</html>
